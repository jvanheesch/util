intent:
create a builder such that:
- builder.stuff() returns compile time type of builder, which may have been reduced to optionX + otherstuff
- somebuilder.optionx() reduces compile time type of builder
dwz dat:
- initBuilder.stuff() returnt typeof(initBuilder)
- initBuilder.optionx() returnt typeof(filterdBuilder)
- initbuilder().optionx.().stuff() returnt typeof(filteredBuilder)
Dat lukt niet in typesystem ALS WE THIS RETURNEN.
maaaar: mss is dat wel mogelijk als we gwn een new builder returnen? !!!!
EDIT:
dit zou niets met return value te maken mogen hebben - is puur type system...

compile-time-type of this has no type name, fml.

Ik denk dat een method haar return type nooit kan afhangen van  de state van this.
en t is puur de state die changed door option1/option2.
TENZIJ je mss this als arg meegeeft?

- returntype van optionx is fixed (vastgelegd dmv params)
- returntype van stuff() is NIET type van this ...
  moet wel type vd view zijn waarop self() wordt gecalled.
  view is daar n collection of interfaces, en die kunnen we niet in variable extracten.




- BaseBuilder<B extends BaseBuilder<B>>: B doStuff();
- BuilderOption1<B extends BuilderOption1>: <R extends B> R option1();
- BuilderOption2<B extends BuilderOption2>: <R extends B> R option2();


doel:
someBuilder()
    .doStuff()
    .doStuff()
    .option1()
    .option2() // compile-error
    .option1()
    .doStuff()
    . ...

kan enkel als builder returnt na .option1() een type heeft dat .option2() niet exposed.
mag perfect over dezelfde builder gaan, en dat kunnen we al.
het probleem is echter dat
result.doStuff() dan terug een api returnt die option1() wel heeft.


Recent idea:
- if builder needs to return a type that exposes all its currently exposed methods, we may
  not need a type for each such combination, if we can somehow use generics to reduce the api.
  example:
  List<?> does not support add operation, only get.
  The problem, however, is that the add method is still present - compiler just won't accept any non-null arg.
  Stel ff:
  Builder<Interface1, Interface2>
  en builder<?, Interface2> kan enkel methods uit interface2 oproepen
  -> todo: type of result after calling such method?

Die generics stuff zou werken als we een clazz hadden waarvoor:
SomeClass<T> has same interface as T, but this is obviously not the case.

Also nog steeds t issue:
- return type ligt vast @ compile time
- return type moet afhangen van state
  -> we bedoelen:
     currentObject.optionX() returnt een type dat optionY() AL DAN NIET exposed.
     die AL DAN NIET hangt af van de state, i.e. de prev method calls.
     -> kunnen we dit wel in type system gieten?
        op zen minst deels - zie existing SomeBuilder !!
        t is te zeggen:
        de magic is als volgt:
        doStuff() heeft return type dat parameterized is,
        en option1() en option2() returnen een builder waarbij die type een verschillende waarde heeft.
        Het enige issue waar we momenteel nog mee zitten, is dat dit type fixed is @ compile time.

========================================================================================================
INITIAL GOAL
========================================================================================================
Using builders for object construction is cool, example:
new CarBuilder()
.bmw()
.sport()
.red()
.build()
or whatever - I don't know shit about cars.
What I want, however, is a builder that prevents certain "errors" @ compile time, such as:
new CarBuilder()
.bmw()
.sport()
.red()
.bmw() // already set the type - don't want this method to be exposed anymore => I want a compilation error !!
.build()
In this case, the solution is rather trivial: the bmw() method could return a builder of the same type as this (CarBuilder),
minus the bmw() method.
This is a relatively simpel case - the "execute-at-most-once" constraint.
I want more advanced cases however, for example:
if .bmw() and .sport() have already been called, .beige() should not be exposed,
as bmw doesn't have any beige sport cars.
Audi does, however, so
new CarBuilder()
.audi()
.sport()
.beige()
.build()
should still work.
